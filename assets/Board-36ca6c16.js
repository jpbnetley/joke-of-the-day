import{j as K,a as Jt,r as p,R as Wt,_ as Zt,C as te}from"./index-142aacb8.js";const Vt="https://www.reddit.com/r/Jokes/.json",ee=async t=>{try{return await(await fetch(Vt,{signal:t})).json()}catch(e){console.error("could not fetch jokes from: ",Vt,e)}},ne=t=>![0,1].includes(t),Mt=t=>{const e=Math.round(Math.random()*100);return e>t&&ne(e)?Mt(t):e},jt=t=>{if(!t.length)return{};const e=Mt(t.length),n=t[e],{title:o,selftext:s}=(n==null?void 0:n.data)??{};return o??s?n:jt(t)},se="_link_hupjz_1",oe={link:se},re=({title:t,joke:e,link:n})=>t&&e&&n?Jt("div",{children:[K("h1",{children:t}),K("p",{children:e}),K("a",{className:oe.link,target:"_blank",rel:"noopener noreferrer",href:n,children:"source"})]}):K("p",{}),ie=async()=>(await ee()).data.children;var Rt={},ce={get exports(){return Rt},set exports(t){Rt=t}},Ut={};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Y=p;function ae(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}var ue=typeof Object.is=="function"?Object.is:ae,le=Y.useState,fe=Y.useEffect,de=Y.useLayoutEffect,he=Y.useDebugValue;function Ee(t,e){var n=e(),o=le({inst:{value:n,getSnapshot:e}}),s=o[0].inst,i=o[1];return de(function(){s.value=n,s.getSnapshot=e,lt(s)&&i({inst:s})},[t,n,e]),fe(function(){return lt(s)&&i({inst:s}),t(function(){lt(s)&&i({inst:s})})},[t]),he(n),n}function lt(t){var e=t.getSnapshot;t=t.value;try{var n=e();return!ue(t,n)}catch{return!0}}function pe(t,e){return e()}var me=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?pe:Ee;Ut.useSyncExternalStore=Y.useSyncExternalStore!==void 0?Y.useSyncExternalStore:me;(function(t){t.exports=Ut})(ce);const x=new WeakMap,ft={},st={},F=()=>{},D=F(),dt=Object,a=t=>t===D,V=t=>typeof t=="function",J=(t,e)=>({...t,...e}),Ct="undefined",rt=typeof window!=Ct,wt=typeof document!=Ct,Re=()=>rt&&typeof window.requestAnimationFrame!=Ct,qt=(t,e)=>{const n=x.get(t);return[()=>t.get(e)||ft,o=>{if(!a(e)){const s=t.get(e);e in st||(st[e]=s),n[5](e,J(s,o),s||ft)}},n[6],()=>!a(e)&&e in st?st[e]:t.get(e)||ft]},ot=new WeakMap;let we=0;const X=t=>{const e=typeof t,n=t&&t.constructor,o=n==Date;let s,i;if(dt(t)===t&&!o&&n!=RegExp){if(s=ot.get(t),s)return s;if(s=++we+"~",ot.set(t,s),n==Array){for(s="@",i=0;i<t.length;i++)s+=X(t[i])+",";ot.set(t,s)}if(n==dt){s="#";const c=dt.keys(t).sort();for(;!a(i=c.pop());)a(t[i])||(s+=i+":"+X(t[i])+",");ot.set(t,s)}}else s=o?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return s};let gt=!0;const ge=()=>gt,[St,_t]=rt&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[F,F],Se=()=>{const t=wt&&document.visibilityState;return a(t)||t!=="hidden"},_e=t=>(wt&&document.addEventListener("visibilitychange",t),St("focus",t),()=>{wt&&document.removeEventListener("visibilitychange",t),_t("focus",t)}),ve=t=>{const e=()=>{gt=!0,t()},n=()=>{gt=!1};return St("online",e),St("offline",n),()=>{_t("online",e),_t("offline",n)}},Ce={isOnline:ge,isVisible:Se},Te={initFocus:_e,initReconnect:ve},Lt=!Wt.useId,Z=!rt||"Deno"in window,ye=t=>Re()?window.requestAnimationFrame(t):setTimeout(t,1),ht=Z?p.useEffect:p.useLayoutEffect,Et=typeof navigator<"u"&&navigator.connection,Nt=!Z&&Et&&(["slow-2g","2g"].includes(Et.effectiveType)||Et.saveData),Tt=t=>{if(V(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?X(t):"",[t,e]};let Oe=0;const vt=()=>++Oe,Pt=0,Ht=1,zt=2;var pt={__proto__:null,FOCUS_EVENT:Pt,RECONNECT_EVENT:Ht,MUTATE_EVENT:zt};async function Bt(...t){const[e,n,o,s]=t,i=J({populateCache:!0,throwOnError:!0},typeof s=="boolean"?{revalidate:s}:s||{});let c=i.populateCache;const d=i.rollbackOnError;let l=i.optimisticData;const C=i.revalidate!==!1,h=T=>typeof d=="function"?d(T):d!==!1,w=i.throwOnError;if(V(n)){const T=n,S=[],_=e.keys();for(let r=_.next();!r.done;r=_.next()){const L=r.value;!L.startsWith("$inf$")&&T(e.get(L)._k)&&S.push(L)}return Promise.all(S.map(O))}return O(n);async function O(T){const[S]=Tt(T);if(!S)return;const[_,r]=qt(e,S),[L,W,M]=x.get(e),N=L[S],U=()=>C&&(delete M[S],N&&N[0])?N[0](zt).then(()=>_().data):_().data;if(t.length<3)return U();let g=o,u;const q=vt();W[S]=[q,0];const I=!a(l),P=_(),it=P.data,tt=P._c,b=a(tt)?it:tt;if(I&&(l=V(l)?l(b):l,r({data:l,_c:b})),V(g))try{g=g(b)}catch(H){u=H}if(g&&V(g.then))if(g=await g.catch(H=>{u=H}),q!==W[S][0]){if(u)throw u;return g}else u&&I&&h(u)&&(c=!0,g=b,r({data:g,_c:D}));c&&(u||(V(c)&&(g=c(g,b)),r({data:g,_c:D}))),W[S][1]=vt();const ct=await U();if(r({_c:D}),u){if(w)throw u;return}return c?ct:g}}const Ft=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},be=(t,e)=>{if(!x.has(t)){const n=J(Te,e),o={},s=Bt.bind(D,t);let i=F;const c={},d=(h,w)=>{const O=c[h]||[];return c[h]=O,O.push(w),()=>O.splice(O.indexOf(w),1)},l=(h,w,O)=>{t.set(h,w);const T=c[h];if(T)for(let S=T.length;S--;)T[S](w,O)},C=()=>{if(!x.has(t)&&(x.set(t,[o,{},{},{},s,l,d]),!Z)){const h=n.initFocus(setTimeout.bind(D,Ft.bind(D,o,Pt))),w=n.initReconnect(setTimeout.bind(D,Ft.bind(D,o,Ht)));i=()=>{h&&h(),w&&w(),x.delete(t)}}};return C(),[t,s,C,i]}return[t,x.get(t)[4]]},De=(t,e,n,o,s)=>{const i=n.errorRetryCount,c=s.retryCount,d=~~((Math.random()+.5)*(1<<(c<8?c:8)))*n.errorRetryInterval;!a(i)&&c>i||setTimeout(o,d,s)},Ie=(t,e)=>X(t)==X(e),[Gt,ke]=be(new Map),Ae=J({onLoadingSlow:F,onSuccess:F,onError:F,onErrorRetry:De,onDiscarded:F,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:Nt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:Nt?5e3:3e3,compare:Ie,isPaused:()=>!1,cache:Gt,mutate:ke,fallback:{}},Ce),xe=(t,e)=>{const n=J(t,e);if(e){const{use:o,fallback:s}=t,{use:i,fallback:c}=e;o&&i&&(n.use=o.concat(i)),s&&c&&(n.fallback=J(s,c))}return n},Ve=p.createContext({}),Kt=rt&&window.__SWR_DEVTOOLS_USE__,Le=Kt?window.__SWR_DEVTOOLS_USE__:[],Ne=()=>{Kt&&(window.__SWR_DEVTOOLS_REACT__=Wt)},Fe=t=>V(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],Je=()=>J(Ae,p.useContext(Ve)),We=t=>(e,n,o)=>t(e,n&&((...i)=>{const c=Tt(e)[0],[,,,d]=x.get(Gt),l=d[c];return l?(delete d[c],l):n(...i)}),o),Me=Le.concat(We),je=t=>function(...n){const o=Je(),[s,i,c]=Fe(n),d=xe(o,c);let l=t;const{use:C}=d,h=(C||[]).concat(Me);for(let w=h.length;w--;)l=h[w](l);return l(s,i||d.fetcher||null,d)},Ue=(t,e,n)=>{const o=e[t]||(e[t]=[]);return o.push(n),()=>{const s=o.indexOf(n);s>=0&&(o[s]=o[o.length-1],o.pop())}};Ne();const mt={dedupe:!0},qe=(t,e,n)=>{const{cache:o,compare:s,suspense:i,fallbackData:c,revalidateOnMount:d,revalidateIfStale:l,refreshInterval:C,refreshWhenHidden:h,refreshWhenOffline:w,keepPreviousData:O}=n,[T,S,_]=x.get(o),[r,L]=Tt(t),W=p.useRef(!1),M=p.useRef(!1),N=p.useRef(r),U=p.useRef(e),g=p.useRef(n),u=()=>g.current,q=()=>u().isVisible()&&u().isOnline(),[I,P,it,tt]=qt(o,r),b=p.useRef({}).current,ct=a(c)?n.fallback[r]:c,H=(f,m)=>{let E=!0;for(const v in b){const R=v;R==="data"?s(m[R],f[R])||a(f[R])&&s(m[R],at)||(E=!1):m[R]!==f[R]&&(E=!1)}return E},yt=p.useMemo(()=>{const f=(()=>!r||!e?!1:a(d)?u().isPaused()||i?!1:a(l)?!0:l:d)(),m=R=>{const k=J(R);return delete k._k,f?{isValidating:!0,isLoading:!0,...k}:k};let E=m(I());const v=m(tt());return[()=>{const R=m(I());return H(R,E)?E:E=R},()=>v]},[o,r]),z=Rt.useSyncExternalStore(p.useCallback(f=>it(r,(m,E)=>{H(E,m)||f()}),[o,r]),yt[0],yt[1]),Ot=!W.current,Yt=T[r]&&T[r].length>0,B=z.data,j=a(B)?ct:B,et=z.error,bt=p.useRef(j),at=O?a(B)?bt.current:B:j,Dt=(()=>Yt&&!a(et)?!1:Ot&&!a(d)?d:u().isPaused()?!1:i?a(j)?!1:l:a(j)||l)(),It=!!(r&&e&&Ot&&Dt),$t=a(z.isValidating)?It:z.isValidating,Qt=a(z.isLoading)?It:z.isLoading,$=p.useCallback(async f=>{const m=U.current;if(!r||!m||M.current||u().isPaused())return!1;let E,v,R=!0;const k=f||{},G=!_[r]||!k.dedupe,Q=()=>Lt?!M.current&&r===N.current&&W.current:r===N.current,nt={isValidating:!1,isLoading:!1},kt=()=>{P(nt)},At=()=>{const y=_[r];y&&y[1]===v&&delete _[r]},xt={isValidating:!0};a(I().data)&&(xt.isLoading=!0);try{if(G&&(P(xt),n.loadingTimeout&&a(I().data)&&setTimeout(()=>{R&&Q()&&u().onLoadingSlow(r,n)},n.loadingTimeout),_[r]=[m(L),vt()]),[E,v]=_[r],E=await E,G&&setTimeout(At,n.dedupingInterval),!_[r]||_[r][1]!==v)return G&&Q()&&u().onDiscarded(r),!1;nt.error=D;const y=S[r];if(!a(y)&&(v<=y[0]||v<=y[1]||y[1]===0))return kt(),G&&Q()&&u().onDiscarded(r),!1;const A=I().data;nt.data=s(A,E)?A:E,G&&Q()&&u().onSuccess(E,r,n)}catch(y){At();const A=u(),{shouldRetryOnError:ut}=A;A.isPaused()||(nt.error=y,G&&Q()&&(A.onError(y,r,A),(ut===!0||V(ut)&&ut(y))&&q()&&A.onErrorRetry(y,r,A,$,{retryCount:(k.retryCount||0)+1,dedupe:!0})))}return R=!1,kt(),!0},[r,o]),Xt=p.useCallback((...f)=>Bt(o,N.current,...f),[]);if(ht(()=>{U.current=e,g.current=n,a(B)||(bt.current=B)}),ht(()=>{if(!r)return;const f=$.bind(D,mt);let m=0;const v=Ue(r,T,R=>{if(R==pt.FOCUS_EVENT){const k=Date.now();u().revalidateOnFocus&&k>m&&q()&&(m=k+u().focusThrottleInterval,f())}else if(R==pt.RECONNECT_EVENT)u().revalidateOnReconnect&&q()&&f();else if(R==pt.MUTATE_EVENT)return $()});return M.current=!1,N.current=r,W.current=!0,P({_k:L}),Dt&&(a(j)||Z?f():ye(f)),()=>{M.current=!0,v()}},[r]),ht(()=>{let f;function m(){const v=V(C)?C(j):C;v&&f!==-1&&(f=setTimeout(E,v))}function E(){!I().error&&(h||u().isVisible())&&(w||u().isOnline())?$(mt).then(m):m()}return m(),()=>{f&&(clearTimeout(f),f=-1)}},[C,h,w,r]),p.useDebugValue(at),i&&a(j)&&r)throw!Lt&&Z?new Error("Fallback data is required when using suspense in SSR."):(U.current=e,g.current=n,M.current=!1,a(et)?$(mt):et);return{mutate:Xt,get data(){return b.data=!0,at},get error(){return b.error=!0,et},get isValidating(){return b.isValidating=!0,$t},get isLoading(){return b.isLoading=!0,Qt}}};var Pe=je(qe);const He=async t=>{const e=t();return Zt.promise(e,{loading:"Getting jokes",success:"Got the Jokes",error:"Could not load jokes"}),e},ze=(t,e,n)=>Pe(t,()=>He(e),n),Be={title:"",selftext:"",url:""},Ke=()=>{const[t,e]=p.useState(!1),[n,o]=p.useState(),s=()=>e(!t),{data:i}=ze("jokes",ie,{suspense:!0});p.useEffect(()=>{const C=()=>{if(!i)return;const h=jt(i),w=h==null?void 0:h.data;e(!t),o(w)};i!=null&&i.length&&(!n||t)&&C()},[i,o,t]);const{title:c,selftext:d,url:l}=n??Be;return Jt(te,{children:[K(re,{title:c,joke:d,link:l}),K("button",{type:"button",onClick:s,children:"Refresh joke"})]})};export{Ke as default};
